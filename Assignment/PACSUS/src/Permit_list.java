import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;

import javax.swing.JFrame;
import javax.swing.JOptionPane;

/* Generated by Together */

/**
 * Permit list manages the collection of permits currently issued and not yet
 * cancelled (or expired). It handles most of the use cases in the
 * Administration section. Note that each Permit must have a unique permit
 * holder name (so a HashTable is probably a good implementation of the
 * collection, with permit holder name as key).
 *
 * There will only be one instance of this class.
 */
public class Permit_list {
	/**
	 * The Permit list maintains a collection of the Permits currently issued.
	 *
	 * This association must be implemented by an attribute holding a collection
	 * data structure (for example: array, hash table - the latter is
	 * recommended).
	 *
	 * Note that no two Permits may have the same permit holder name (this
	 * information is not represented diagrammatically).
	 * 
	 * @associates Permit
	 * @label Contains
	 * @clientCardinality 1
	 * @supplierCardinality 0..*
	 * @directed
	 */
	private Hashtable<String, Permit> lnkPermit;

	/**
	 * Basic constructor to be called when system is launched
	 * 
	 * @author Nicholas Whitton
	 */
	public Permit_list() {
		lnkPermit = new Hashtable<String, Permit>();
	}

	// Changed to boolean to stop admin from displaying
	/**
	 * Adds a permit to the list if the person does not already have a permit
	 * 
	 * @param permit
	 *            the permit to be added
	 * @author Nicholas Whitton
	 */
	public boolean addPermit(Permit permit, JFrame source) {
		if (lnkPermit.get(permit.getHolder()) != null) {
			JOptionPane.showMessageDialog(source,
					"There is already a permit registered to that person: " + permit.getHolder(), "Duplicate Permit",
					JOptionPane.WARNING_MESSAGE);
			return false;
		}
		lnkPermit.put(permit.getHolder(), permit);
		return true;
	}

	/**
	 * method to remove a permit from the permit list if the permit exists
	 * 
	 * @param permit
	 *            : permit to remove
	 * @param source
	 *            : The frame to display JOption
	 * @return
	 * @author Robert
	 */
	public boolean removePermit(Permit permit, JFrame source) {
		if (lnkPermit.get(permit.getHolder()) == null) {
			JOptionPane.showMessageDialog(source, "There is no permit registered to that person: " + permit.getHolder(),
					"No such Permit", JOptionPane.WARNING_MESSAGE);
			return false;
		} else {
			lnkPermit.remove(permit.getHolder());
			for (Vehicle_info v : permit.getVehicles()) {
				v.setPermit(null);
			}
			return true;
		}
	}

	/**
	 * Updates the list at the end of the year, renewing all permits which have
	 * not yet expired.
	 * 
	 * @author Nicholas Whitton
	 */
	private void annualUpdate() {
		ArrayList<Permit> allEntries = getAll();
		Permit renewedPermit = null;
		for (Permit permit : allEntries) {
			removePermit(permit, null);

			if (permit instanceof Permanent_visitor_permit)
			// if permit type is a permanent visitor
			{
				lnkPermit.put(permit.getHolder(),
						renewedPermit = new Permanent_visitor_permit((Permanent_visitor_permit) permit));
			} else if (permit instanceof Regular_visitor_permit
					&& ((Regular_visitor_permit) permit).getLastDay().getDay() != Date.yearLength)
			// if permit type is a regular visitor but expires after the start
			// of the new year
			{
				lnkPermit.put(permit.getHolder(),
						renewedPermit = new Regular_visitor_permit((Regular_visitor_permit) permit));
			} else if (permit instanceof Day_visitor_permit
					&& ((Day_visitor_permit) permit).getDate().getDay() != Date.yearLength)
			// if permit type is a day visitor but expires after the start of
			// the new year
			{
				lnkPermit.put(permit.getHolder(), renewedPermit = new Day_visitor_permit((Day_visitor_permit) permit));
			} else if (permit instanceof University_member_permit)
			// if permit type is a university member type (auto renews each new
			// year)
			{
				lnkPermit.put(permit.getHolder(),
						renewedPermit = new University_member_permit((University_member_permit) permit));
			}
			for (Vehicle_info v : permit.getVehicles()) {
				v.setPermit(renewedPermit);
			}
		}
	}

	/**
	 * Removes all permits which have passed their expiry date
	 * 
	 * @author Nicholas Whitton
	 */
	private void removeExpired(Date currDate) {
		ArrayList<Permit> allEntries = getAll();
		for (Permit permit : allEntries) {
			if (permit instanceof Day_visitor_permit
					&& ((Day_visitor_permit) permit).getDate().getDay() == currDate.getDay() - 1)
			// if permit type is a day visitor and expired yesterday
			{
				removePermit(permit, null);
			} else if (permit instanceof Regular_visitor_permit
					&& ((Regular_visitor_permit) permit).getLastDay().getDay() == currDate.getDay() - 1)
			// if permit type is a regular visitor and expired yesterday
			{
				removePermit(permit, null);
			} else {
				permit.notifyEndOfDay();
			}
		}
	}

	/**
	 * Gets the permit belonging to the specified holder
	 * 
	 * @param holder
	 *            the person to retrieve a permit for
	 * @author Nicholas Whitton
	 */
	public Permit get(String holder) {
		return lnkPermit.get(holder);
	}

	/**
	 * Gets all entries in the permit list
	 * 
	 * @return all entries in the permit list
	 */
	public ArrayList<Permit> getAll() {
		ArrayList<Permit> permits = new ArrayList<Permit>();
		Enumeration<String> keys = lnkPermit.keys();
		while (keys.hasMoreElements()) {
			permits.add(lnkPermit.get(keys.nextElement()));
		}
		return permits;
	}

	/**
	 * Alerts the list that the date has changed and performs actions based on
	 * whether or not it is a new year
	 * 
	 * @param date
	 *            the new date
	 */
	public void informNewDate(Date date) {
		if (date.getDay() == 1) // if date is equal to 1 which happen when day
								// exceeds year length
		{
			annualUpdate();
		} else {
			removeExpired(date);
		}
	}
}
